package tui

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/lipgloss"
)

// Layout manager for proper TUI organization
type Layout struct {
	width  int
	height int
}

func NewLayout(width, height int) Layout {
	return Layout{width: width, height: height}
}

// Render main layout with minimal spacing
func (l Layout) RenderMain(header, tabs, content, footer string) string {
	// Calculate available space with minimal margins
	headerHeight := lipgloss.Height(header)
	tabsHeight := lipgloss.Height(tabs)
	footerHeight := lipgloss.Height(footer)
	contentHeight := l.height - headerHeight - tabsHeight - footerHeight - 1 // minimal margin

	// Ensure content fits in available space
	if contentHeight < 3 {
		contentHeight = 3
	}

	// Create main container with minimal spacing
	var output strings.Builder
	
	// Header (no extra spacing)
	output.WriteString(header)
	
	// Tabs (no extra spacing)
	output.WriteString("\n")
	output.WriteString(tabs)
	
	// Content (prefer scrolling over truncation)
	output.WriteString("\n")
	if lipgloss.Height(content) > contentHeight {
		// Instead of truncating, compress spacing within content
		compressedContent := l.compressContentSpacing(content, contentHeight)
		output.WriteString(compressedContent)
	} else {
		output.WriteString(content)
	}
	
	// Footer (minimal spacing)
	output.WriteString("\n")
	output.WriteString(footer)
	
	return output.String()
}

// Compress content spacing instead of truncating
func (l Layout) compressContentSpacing(content string, maxHeight int) string {
	lines := strings.Split(content, "\n")
	
	if len(lines) <= maxHeight {
		return content
	}
	
	// Remove empty lines and reduce spacing
	var compressed []string
	for i, line := range lines {
		// Skip consecutive empty lines
		if line == "" && i > 0 && i < len(lines)-1 && lines[i-1] == "" {
			continue
		}
		compressed = append(compressed, line)
		
		// Stop if we hit the limit but preserve important content
		if len(compressed) >= maxHeight-1 {
			break
		}
	}
	
	// If still too long, show most recent content (like logs)
	if len(compressed) > maxHeight {
		start := len(compressed) - maxHeight + 1
		compressed = compressed[start:]
		compressed = append([]string{"... (showing recent content)"}, compressed...)
	}
	
	return strings.Join(compressed, "\n")
}

// Legacy function for backwards compatibility
func (l Layout) constrainContent(content string, maxHeight int) string {
	return l.compressContentSpacing(content, maxHeight)
}

// Create stylish header with rounded corners
func (l Layout) RenderHeader(title string) string {
	headerStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(primaryColor).
		Align(lipgloss.Center).
		Width(l.width - 4). // Account for borders
		Border(lipgloss.RoundedBorder()).
		BorderForeground(primaryColor).
		Padding(0, 1)
	
	return headerStyle.Render(title)
}

// Create responsive tab bar
func (l Layout) RenderTabs(tabs []string, activeIndex int) string {
	if len(tabs) == 0 {
		return ""
	}
	
	// Calculate tab width more conservatively
	availableWidth := l.width - 8 // Account for overall margins and spacing
	tabWidth := availableWidth / len(tabs)
	if tabWidth < 8 {
		tabWidth = 8
	}
	if tabWidth > 20 {
		tabWidth = 20 // Max width to prevent too-wide tabs
	}
	
	var renderedTabs []string
	for i, tab := range tabs {
		style := lipgloss.NewStyle().
			Width(tabWidth).
			Align(lipgloss.Center)
		
		if i == activeIndex {
			style = style.
				Foreground(primaryColor).
				Bold(true).
				Border(lipgloss.RoundedBorder()).
				BorderForeground(primaryColor).
				Padding(0, 1)
		} else {
			style = style.
				Foreground(lipgloss.Color("245")).
				Border(lipgloss.RoundedBorder()).
				BorderForeground(lipgloss.Color("245")).
				Padding(0, 1)
		}
		
		renderedTabs = append(renderedTabs, style.Render(tab))
	}
	
	// Join tabs with proper spacing control
	tabsLine := lipgloss.JoinHorizontal(lipgloss.Top, renderedTabs...)
	
	// Ensure it doesn't exceed terminal width
	if lipgloss.Width(tabsLine) > l.width {
		// Fallback to simpler tab rendering if too wide
		var simpleTabs []string
		simpleTabWidth := (l.width - 4) / len(tabs)
		for i, tab := range tabs {
			style := lipgloss.NewStyle().Width(simpleTabWidth).Align(lipgloss.Center)
			if i == activeIndex {
				style = style.Foreground(primaryColor).Bold(true)
			} else {
				style = style.Foreground(lipgloss.Color("245"))
			}
			simpleTabs = append(simpleTabs, style.Render(tab))
		}
		return lipgloss.JoinHorizontal(lipgloss.Top, simpleTabs...)
	}
	
	return tabsLine
}

// Create system stats row with better space utilization
func (l Layout) RenderStatsRow(memUsed, memPercent float64, uptime string, goroutines int, workflowCount, runningCount int) string {
	// Card width calculation - account for spacing, padding, and borders
	cardWidth := (l.width - 12) / 3 // 3 cards with spacing, borders, and margins
	if cardWidth < 20 {
		cardWidth = 20
	}
	
	// Stylish stats cards with rounded corners
	memCard := lipgloss.NewStyle().
		Width(cardWidth).
		Border(lipgloss.RoundedBorder()).
		BorderForeground(accentColor).
		Align(lipgloss.Center).
		Padding(1).
		Render(fmt.Sprintf("ðŸ’¾ Memory\n%.1fMB (%.1f%%)", memUsed, memPercent))
	
	// Uptime card
	uptimeCard := lipgloss.NewStyle().
		Width(cardWidth).
		Border(lipgloss.RoundedBorder()).
		BorderForeground(accentColor).
		Align(lipgloss.Center).
		Padding(1).
		Render(fmt.Sprintf("â±ï¸ Uptime\n%s\n%d routines", uptime, goroutines))
	
	// Workflow card
	workflowCard := lipgloss.NewStyle().
		Width(cardWidth).
		Border(lipgloss.RoundedBorder()).
		BorderForeground(successColor).
		Align(lipgloss.Center).
		Padding(1).
		Render(fmt.Sprintf("âš¡ Workflows\n%d total\n%d running", workflowCount, runningCount))
	
	return lipgloss.JoinHorizontal(lipgloss.Top, memCard, " ", uptimeCard, " ", workflowCard)
}

// Create compact content area
func (l Layout) RenderContentArea(title string, content string, maxHeight int) string {
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(primaryColor)
	
	// Stylish container for content with proper width calculation
	containerStyle := lipgloss.NewStyle().
		Width(l.width - 4). // Account for borders
		Border(lipgloss.RoundedBorder()).
		BorderForeground(primaryColor).
		Padding(1)
	
	var fullContent strings.Builder
	fullContent.WriteString(titleStyle.Render(title))
	fullContent.WriteString("\n")
	fullContent.WriteString(content)
	
	compressedContent := l.compressContentSpacing(fullContent.String(), maxHeight-3) // Account for padding
	return containerStyle.Render(compressedContent)
}

// Create footer with help text
func (l Layout) RenderFooter(helpText string) string {
	footerStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("245")).
		Width(l.width).
		Align(lipgloss.Center).
		Italic(true)
	
	return footerStyle.Render(helpText)
}

// Render components with proper constraints
func (l Layout) RenderTable(tableView string, maxHeight int) string {
	// Constrain table to fit in allocated space
	lines := strings.Split(tableView, "\n")
	
	if len(lines) > maxHeight {
		// Keep header and truncate data
		header := lines[0]
		dataLines := lines[1:]
		
		if len(dataLines) > maxHeight-2 {
			dataLines = dataLines[:maxHeight-2]
			dataLines = append(dataLines, "... (more entries)")
		}
		
		constrainedLines := []string{header}
		constrainedLines = append(constrainedLines, dataLines...)
		return strings.Join(constrainedLines, "\n")
	}
	
	return tableView
}

// Render list with proper constraints  
func (l Layout) RenderList(listView string, maxHeight int) string {
	return l.constrainContent(listView, maxHeight)
}