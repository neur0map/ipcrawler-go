package tui

import (
	"fmt"
	"strings"
	"time"
)

// View renders the TUI using proper layout management
func (m ProperMonitorModel) View() string {
	if m.terminated {
		return ""
	}

	// Create layout manager
	layout := NewLayout(m.width, m.height)

	// Header
	header := layout.RenderHeader(fmt.Sprintf("üéØ IPCrawler - %s", m.target))

	// Tabs
	tabNames := []string{"Overview", "Workflows", "Tools", "Logs"}
	tabs := layout.RenderTabs(tabNames, m.activeTab)

	// Content based on active tab
	var content string
	switch m.activeTab {
	case 0:
		content = m.renderOverviewContent(layout)
	case 1:
		content = m.renderWorkflowsContent(layout)
	case 2:
		content = m.renderToolsContent(layout)
	case 3:
		content = m.renderLogsContent(layout)
	}

	// Footer
	var footer string
	if m.showHelp {
		footer = m.renderHelpContent(layout)
	} else {
		footer = layout.RenderFooter("Press 'h' for help ‚Ä¢ tab/arrows to navigate ‚Ä¢ 1-4 for direct tabs ‚Ä¢ 'q' to quit")
	}

	// Combine with layout manager
	return layout.RenderMain(header, tabs, content, footer)
}

// Overview tab with proper layout
func (m ProperMonitorModel) renderOverviewContent(layout Layout) string {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var content strings.Builder

	// System stats row
	memMB := float64(m.systemStats.MemoryUsed) / 1024 / 1024
	uptime := formatDuration(m.systemStats.Uptime)
	
	// Count running workflows
	runningCount := 0
	for _, wf := range m.workflows {
		if wf.Status == "running" {
			runningCount++
		}
	}
	
	statsRow := layout.RenderStatsRow(
		memMB, m.systemStats.MemoryPercent,
		uptime, m.systemStats.Goroutines,
		len(m.workflows), runningCount,
	)
	content.WriteString(statsRow)
	content.WriteString("\n")

	// Calculate remaining space for content (more space available with compact layout)
	remainingHeight := layout.height - 8 // Compact header, tabs, stats, footer

	// Split remaining space between workflows and activity
	workflowHeight := remainingHeight / 2
	activityHeight := remainingHeight - workflowHeight

	// Active workflows section
	if runningCount > 0 {
		workflowContent := m.renderRunningWorkflows()
		workflowSection := layout.RenderContentArea("üöÄ Active Workflows", workflowContent, workflowHeight)
		content.WriteString(workflowSection)
	}

	// Live activity section
	activityContent := m.renderRecentActivity()
	activitySection := layout.RenderContentArea("üì° Live Activity", activityContent, activityHeight)
	content.WriteString(activitySection)

	return content.String()
}

// Workflows tab with proper layout
func (m ProperMonitorModel) renderWorkflowsContent(layout Layout) string {
	if len(m.workflows) == 0 {
		return layout.RenderContentArea("‚ö° Workflow Dashboard", 
			"No workflows detected. Start a scan to see workflows here.", 
			layout.height-6)
	}

	// Constrain table to fit in available space
	tableView := m.workflowTable.View()
	constrainedTable := layout.RenderTable(tableView, layout.height-6)
	
	return layout.RenderContentArea("‚ö° Workflow Dashboard", constrainedTable, layout.height-6)
}

// Tools tab with proper layout
func (m ProperMonitorModel) renderToolsContent(layout Layout) string {
	if len(m.tools) == 0 {
		return layout.RenderContentArea("üîß Tool Monitor", 
			"No tool executions yet. Tools will appear here as they run.", 
			layout.height-6)
	}

	// Constrain table to fit in available space
	tableView := m.toolsTable.View()
	constrainedTable := layout.RenderTable(tableView, layout.height-6)
	
	return layout.RenderContentArea("üîß Tool Monitor", constrainedTable, layout.height-6)
}

// Logs tab with proper layout
func (m ProperMonitorModel) renderLogsContent(layout Layout) string {
	if len(m.logs) == 0 {
		return layout.RenderContentArea("üìã Execution Logs", 
			"No logs available. Logs will appear here as operations execute.", 
			layout.height-6)
	}

	// Use viewport for scrollable logs
	logsContent := m.logsViewport.View()
	
	return layout.RenderContentArea("üìã Execution Logs", logsContent, layout.height-6)
}

// Help content with proper layout
func (m ProperMonitorModel) renderHelpContent(layout Layout) string {
	helpText := `üéØ IPCrawler TUI Help

Navigation:
  tab / ‚Üí / l      Next tab
  shift+tab / ‚Üê    Previous tab  
  1, 2, 3, 4       Direct tab selection
  ‚Üë / ‚Üì / j / k    Navigate within tables and lists
  pgup / pgdown    Scroll in logs view
  
Controls:
  h                Toggle this help
  q, Ctrl+C        Quit and CANCEL running scans
  
Tabs:
  Overview         Live system status and activity
  Workflows        Workflow execution monitoring  
  Tools            Tool execution history
  Logs             Scrollable execution logs
  
The interface updates in real-time as workflows execute.
Press 'q' to stop all running scans and exit.`

	return layout.RenderContentArea("üí° Help", helpText, layout.height-4)
}

// Helper functions for content rendering
func (m ProperMonitorModel) renderRunningWorkflows() string {
	var content strings.Builder
	
	runningWorkflows := []WorkflowStatus{}
	for _, wf := range m.workflows {
		if wf.Status == "running" {
			runningWorkflows = append(runningWorkflows, wf)
		}
	}
	
	if len(runningWorkflows) == 0 {
		return "No workflows currently running..."
	}
	
	// Sort by start time to show consistent order
	for i, wf := range runningWorkflows {
		elapsed := formatDuration(wf.GetElapsed())
		line := fmt.Sprintf("%s %s - Running for %s", 
			getStatusIcon(wf.Status), wf.ID, elapsed)
		content.WriteString(line)
		
		// Add separator between workflows except for the last one
		if i < len(runningWorkflows)-1 {
			content.WriteString("\n")
		}
	}
	
	// Add summary line if multiple workflows are running
	if len(runningWorkflows) > 1 {
		content.WriteString(fmt.Sprintf("\n\nüìä %d workflows running in parallel", len(runningWorkflows)))
	}
	
	return content.String()
}

func (m ProperMonitorModel) renderRecentActivity() string {
	if len(m.logs) == 0 {
		return "No recent activity..."
	}
	
	var content strings.Builder
	
	// Show last 5 log entries
	start := len(m.logs) - 5
	if start < 0 {
		start = 0
	}
	
	for _, log := range m.logs[start:] {
		timestamp := log.Timestamp.Format("15:04:05")
		line := fmt.Sprintf("[%s] %s: %s", timestamp, log.Category, log.Message)
		content.WriteString(line)
		content.WriteString("\n")
	}
	
	return content.String()
}

// Add helper method to WorkflowStatus
func (w WorkflowStatus) GetElapsed() time.Duration {
	if w.Status == "running" {
		return time.Since(w.StartTime)
	}
	return w.Duration
}